From 7b2a73963c91cf6bad6b8f58636560cd1f3cf319 Mon Sep 17 00:00:00 2001
From: Andrew Vasquez <andrewv@marvell.com>
Date: Wed, 26 Feb 2020 14:40:11 -0800
Subject: [PATCH] scsi: qla2xxx: Use a dedicated interrupt handler for
 'handshake-required' ISPs

There's no point checking flags.disable_msix_handshake in the
interrupt handler hot-path.  Instead perform the check during
queue-pair instantiation and use the proper interrupt handler.

Link: https://lore.kernel.org/r/20200226224022.24518-8-hmadhani@marvell.com
Signed-off-by: Himanshu Madhani <hmadhani@marvell.com>
Signed-off-by: Andrew Vasquez <andrewv@marvell.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
---
 qla2x00t-32gbit/qla_def.h |  1 +
 qla2x00t-32gbit/qla_gbl.h |  2 ++
 qla2x00t-32gbit/qla_isr.c | 31 ++++++++++++++++++++++++-------
 qla2x00t-32gbit/qla_mid.c |  3 ++-
 4 files changed, 29 insertions(+), 8 deletions(-)

Index: scst-3.4.x/qla2x00t-32gbit/qla_def.h
===================================================================
--- scst-3.4.x.orig/qla2x00t-32gbit/qla_def.h
+++ scst-3.4.x/qla2x00t-32gbit/qla_def.h
@@ -3258,6 +3258,7 @@ struct isp_operations {
 #define QLA_MSIX_RSP_Q			0x01
 #define QLA_ATIO_VECTOR		0x02
 #define QLA_MSIX_QPAIR_MULTIQ_RSP_Q	0x03
+#define QLA_MSIX_QPAIR_MULTIQ_RSP_Q_HS	0x04
 
 #define QLA_MIDX_DEFAULT	0
 #define QLA_MIDX_RSP_Q		1
Index: scst-3.4.x/qla2x00t-32gbit/qla_gbl.h
===================================================================
--- scst-3.4.x.orig/qla2x00t-32gbit/qla_gbl.h
+++ scst-3.4.x/qla2x00t-32gbit/qla_gbl.h
@@ -555,6 +555,8 @@ qla2x00_process_completed_request(struct
 	uint32_t);
 extern irqreturn_t
 qla2xxx_msix_rsp_q(int irq, void *dev_id);
+extern irqreturn_t
+qla2xxx_msix_rsp_q_hs(int irq, void *dev_id);
 fc_port_t *qla2x00_find_fcport_by_loopid(scsi_qla_host_t *, uint16_t);
 fc_port_t *qla2x00_find_fcport_by_wwpn(scsi_qla_host_t *, u8 *, u8);
 fc_port_t *qla2x00_find_fcport_by_nportid(scsi_qla_host_t *, port_id_t *, u8);
Index: scst-3.4.x/qla2x00t-32gbit/qla_isr.c
===================================================================
--- scst-3.4.x.orig/qla2x00t-32gbit/qla_isr.c
+++ scst-3.4.x/qla2x00t-32gbit/qla_isr.c
@@ -3418,6 +3418,25 @@ qla2xxx_msix_rsp_q(int irq, void *dev_id
 {
 	struct qla_hw_data *ha;
 	struct qla_qpair *qpair;
+
+	qpair = dev_id;
+	if (!qpair) {
+		ql_log(ql_log_info, NULL, 0x505b,
+		    "%s: NULL response queue pointer.\n", __func__);
+		return IRQ_NONE;
+	}
+	ha = qpair->hw;
+
+	queue_work(ha->wq, &qpair->q_work);
+
+	return IRQ_HANDLED;
+}
+
+irqreturn_t
+qla2xxx_msix_rsp_q_hs(int irq, void *dev_id)
+{
+	struct qla_hw_data *ha;
+	struct qla_qpair *qpair;
 	struct device_reg_24xx __iomem *reg;
 	unsigned long flags;
 
@@ -3429,13 +3448,10 @@ qla2xxx_msix_rsp_q(int irq, void *dev_id
 	}
 	ha = qpair->hw;
 
-	/* Clear the interrupt, if enabled, for this response queue */
-	if (unlikely(!ha->flags.disable_msix_handshake)) {
-		reg = &ha->iobase->isp24;
-		spin_lock_irqsave(&ha->hardware_lock, flags);
-		WRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);
-		spin_unlock_irqrestore(&ha->hardware_lock, flags);
-	}
+	reg = &ha->iobase->isp24;
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	WRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
 
 	queue_work(ha->wq, &qpair->q_work);
 
@@ -3467,6 +3483,7 @@ static const struct qla_init_msix_entry
 	{ "rsp_q", qla24xx_msix_rsp_q },
 	{ "atio_q", qla83xx_msix_atio_q },
 	{ "qpair_multiq", qla2xxx_msix_rsp_q },
+	{ "qpair_multiq_hs", qla2xxx_msix_rsp_q_hs },
 };
 
 static const struct qla_init_msix_entry qla82xx_msix_entries[] = {
Index: scst-3.4.x/qla2x00t-32gbit/qla_mid.c
===================================================================
--- scst-3.4.x.orig/qla2x00t-32gbit/qla_mid.c
+++ scst-3.4.x/qla2x00t-32gbit/qla_mid.c
@@ -886,7 +886,8 @@ qla25xx_create_rsp_que(struct qla_hw_dat
 	    rsp->rsp_q_out);
 
 	ret = qla25xx_request_irq(ha, qpair, qpair->msix,
-	    QLA_MSIX_QPAIR_MULTIQ_RSP_Q);
+		ha->flags.disable_msix_handshake ?
+		QLA_MSIX_QPAIR_MULTIQ_RSP_Q : QLA_MSIX_QPAIR_MULTIQ_RSP_Q_HS);
 	if (ret)
 		goto que_failed;
 
