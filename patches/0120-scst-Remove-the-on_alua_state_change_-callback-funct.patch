From 29548a4ad71729ac68d897a6150e1b34184d9264 Mon Sep 17 00:00:00 2001
From: Bart Van Assche <bvanassche@acm.org>
Date: Thu, 14 May 2020 16:36:30 +0000
Subject: [PATCH] scst: Remove the on_alua_state_change_*() callback functions

Remove these callback functions because:
- Since the introduction of the 'active' attribute, these callback functions
  are no longer essential. See also commit 9d21169f8c5d ("scst: implement
  BLOCKIO devices "active" attribute").
- The current implementation may break I/O. The following ALUA configuration
  is sufficient to break I/O (because a remote group with state 'standby'
  occurs last):

DEVICE_GROUP dgroup1 {
	DEVICE disk01

	TARGET_GROUP tgroup1 {
		group_id 256
		preferred 1
		state active
		TARGET scst_local_tgt
	}
	TARGET_GROUP tgroup2 {
		group_id 257
		state standby
		TARGET scst_local_tgt_remote {
			rel_tgt_id 7
		}
	}
}

See also commit 2b202209cad4 ("ALUA DRBD compatibility").



git-svn-id: http://svn.code.sf.net/p/scst/svn/trunk@8912 d57e44dd-8a1f-0410-8b47-8ef2f437770f
---
 scst/include/scst.h                | 28 ---------
 scst/src/dev_handlers/scst_vdisk.c | 92 +-----------------------------
 scst/src/scst_tg.c                 |  9 ---
 3 files changed, 1 insertion(+), 128 deletions(-)

diff --git a/scst/include/scst.h b/scst/include/scst.h
index 8bbe8093..a3453f0e 100644
--- a/scst/include/scst.h
+++ b/scst/include/scst.h
@@ -1401,34 +1401,6 @@ struct scst_dev_type {
 	void (*ext_copy_remap)(struct scst_cmd *cmd,
 		struct scst_ext_copy_seg_descr *descr);
 
-	/*
-	 * Called to notify dev handler that a ALUA state change is about to
-	 * be started. Can be used to close open file handlers, which might
-	 * prevent the state switch.
-	 *
-	 * Called under scst_dg_mutex and no activities on the dev handler level
-	 * (for implicit ALUA case supposed to be done by the user space via
-	 * "block" sysfs attribute as described in the README).
-	 *
-	 * OPTIONAL
-	 */
-	void (*on_alua_state_change_start)(struct scst_device *dev,
-		enum scst_tg_state old_state, enum scst_tg_state new_state);
-
-	/*
-	 * Called to notify dev handler that a ALUA state change is about to
-	 * be finished. Can be used to (re)open file handlers closed in
-	 * on_alua_state_change_start().
-	 *
-	 * Called under scst_dg_mutex and no activities on the dev handler level
-	 * (for implicit ALUA case supposed to be done by the user space via
-	 * "block" sysfs attribute as described in the README).
-	 *
-	 * OPTIONAL
-	 */
-	void (*on_alua_state_change_finish)(struct scst_device *dev,
-		enum scst_tg_state old_state, enum scst_tg_state new_state);
-
 	/*
 	 * Called to notify dev handler that a task management command received
 	 *
diff --git a/scst/src/dev_handlers/scst_vdisk.c b/scst/src/dev_handlers/scst_vdisk.c
index 60cc939e..79a6eb4d 100644
--- a/scst/src/dev_handlers/scst_vdisk.c
+++ b/scst/src/dev_handlers/scst_vdisk.c
@@ -6446,91 +6446,6 @@ static enum compl_status_e nullio_exec_verify(struct vdisk_cmd_params *p)
 	return CMD_SUCCEEDED;
 }
 
-static void blockio_on_alua_state_change_start(struct scst_device *dev,
-	enum scst_tg_state old_state, enum scst_tg_state new_state)
-{
-	struct scst_vdisk_dev *virt_dev = dev->dh_priv;
-
-	TRACE_ENTRY();
-
-	lockdep_assert_alua_lock_held();
-
-	if (!virt_dev->bind_alua_state)
-		return;
-
-	/*
-	 * As required for on_alua_state_change_* callbacks,
-	 * no parallel fd activities could be here.
-	 */
-
-	TRACE_MGMT_DBG("ALUA state change from %s to %s started, closing FD (dev %s, active %d)",
-		scst_alua_state_name(old_state), scst_alua_state_name(new_state),
-		dev->virt_name, virt_dev->dev_active);
-
-	virt_dev->dev_active = 0;
-
-	/* Just in case always close */
-	vdisk_close_fd(virt_dev);
-
-	TRACE_EXIT();
-	return;
-}
-
-static void blockio_on_alua_state_change_finish(struct scst_device *dev,
-	enum scst_tg_state old_state, enum scst_tg_state new_state)
-{
-	struct scst_vdisk_dev *virt_dev = dev->dh_priv;
-
-	TRACE_ENTRY();
-
-	lockdep_assert_alua_lock_held();
-
-	if (!virt_dev->bind_alua_state)
-		return;
-
-	/*
-	 * As required for on_alua_state_change_* callbacks,
-	 * no parallel fd activities could be here.
-	 */
-
-	if (((new_state == SCST_TG_STATE_OPTIMIZED) ||
-	     (new_state == SCST_TG_STATE_NONOPTIMIZED)) && (virt_dev->fd == NULL)) {
-		/* Try non-optimized as well, it might be new redirection device */
-		int rc = 0;
-
-		TRACE_MGMT_DBG("ALUA state change from %s to %s finished (dev %s, active %d), "
-			"reopening FD", scst_alua_state_name(old_state),
-			scst_alua_state_name(new_state), dev->virt_name, virt_dev->dev_active);
-
-		virt_dev->dev_active = 1;
-
-		/*
-		 * only reopen fd if tgt_dev_cnt is not zero, otherwise we will
-		 * leak reference.
-		 */
-		if (virt_dev->tgt_dev_cnt)
-			rc = vdisk_open_fd(virt_dev, dev->dev_rd_only);
-
-		if (rc == 0) {
-			if (virt_dev->reexam_pending) {
-				rc = vdisk_reexamine(virt_dev);
-				WARN_ON(rc != 0);
-				virt_dev->reexam_pending = 0;
-			}
-		} else {
-			PRINT_ERROR("Unable to open fd on ALUA state change "
-				"to %s (dev %s)", dev->virt_name,
-				scst_alua_state_name(new_state));
-		}
-	} else
-		TRACE_DBG("ALUA state change from %s to %s finished (dev %s)",
-			scst_alua_state_name(old_state), scst_alua_state_name(new_state),
-			dev->virt_name);
-
-	TRACE_EXIT();
-	return;
-}
-
 static void vdisk_task_mgmt_fn_done(struct scst_mgmt_cmd *mcmd,
 	struct scst_tgt_dev *tgt_dev)
 {
@@ -9406,10 +9321,7 @@ static int vdev_sysfs_process_active_store(
 	res = mutex_lock_interruptible(&scst_mutex);
 	if (res)
 		goto resume;
-	/*
-	 * This is used to serialize against the *_on_alua_state_change_*()
-	 * calls in scst_tg.c
-	 */
+	/* To do: verify whether this call is still necessary. */
 	scst_alua_lock();
 
 	/*
@@ -9891,8 +9803,6 @@ static struct scst_dev_type vdisk_blk_devtype = {
 	.detach_tgt =		vdisk_detach_tgt,
 	.parse =		non_fileio_parse,
 	.exec =			blockio_exec,
-	.on_alua_state_change_start = blockio_on_alua_state_change_start,
-	.on_alua_state_change_finish = blockio_on_alua_state_change_finish,
 	.task_mgmt_fn_done =	vdisk_task_mgmt_fn_done,
 	.get_supported_opcodes = vdisk_get_supported_opcodes,
 	.devt_priv =		(void *)blockio_ops,
diff --git a/scst/src/scst_tg.c b/scst/src/scst_tg.c
index 8b6b1a6f..b316ac18 100644
--- a/scst/src/scst_tg.c
+++ b/scst/src/scst_tg.c
@@ -976,8 +976,6 @@ static void __scst_tg_set_state(struct scst_target_group *tg,
 	struct scst_tgt_dev *tgt_dev;
 	struct scst_tg_tgt *tg_tgt;
 	struct scst_tgt *tgt;
-	enum scst_tg_state old_state = tg->state;
-	bool dev_changed;
 
 	sBUG_ON(state >= ARRAY_SIZE(scst_alua_filter));
 	lockdep_assert_held(&scst_dg_mutex);
@@ -989,11 +987,6 @@ static void __scst_tg_set_state(struct scst_target_group *tg,
 
 	list_for_each_entry(dg_dev, &tg->dg->dev_list, entry) {
 		dev = dg_dev->dev;
-		dev_changed = false;
-		if ((dev->handler->on_alua_state_change_start != NULL) && !dev_changed) {
-			dev->handler->on_alua_state_change_start(dev, old_state, state);
-			dev_changed = true;
-		}
 		list_for_each_entry(tgt_dev, &dev->dev_tgt_dev_list,
 				    dev_tgt_dev_list_entry) {
 			tgt = tgt_dev->sess->tgt;
@@ -1010,8 +1003,6 @@ static void __scst_tg_set_state(struct scst_target_group *tg,
 				}
 			}
 		}
-		if ((dev->handler->on_alua_state_change_finish != NULL) && dev_changed)
-			dev->handler->on_alua_state_change_finish(dev, old_state, state);
 	}
 
 	scst_check_alua_invariant();
-- 
2.26.2

